import numpy as np
import matplotlib.pyplot as plt

""""""

def abline(slope, intercept):
    """Plot a line from slope and intercept"""
    plt.figure(1)
    axes = plt.gca()
    x_vals = np.array(axes.get_xlim())
    y_vals = intercept + slope * x_vals
    plt.plot(x_vals, y_vals, '--')


"""load the data generated by network1.py"""

training_set = np.load('s_allPoints.npy')
supervised_s_0 = np.load('s_0_point.npy')
supervised_s_0 = np.ndarray.tolist(supervised_s_0)
supervised_s_1 = np.load('s_1_points.npy')
supervised_s_1 = np.ndarray.tolist(supervised_s_1)

""""""
learning_rate = 1

"""loading the initial weights from initialWeights.npy file"""

load_weights = np.load('ptaWeights.npy')
w_0 = load_weights[0]
w_1 = load_weights[1]
w_2 = load_weights[2]
w_array = np.array([w_0[0], w_1[0], w_2[0]])

print ("initial weights PTA:::", w_array)
all_weights = []
epoch = 0
wrong_classification = 0
exit_condition = 1

# figure-2 is the Epochs Vs Misclassifications
plt.figure(2)
plt.plot(0, 0, 'xr-')

"""start PTA"""
while True:
    # while exit_condition == 1:
    wrong_classification = 0
    epoch = epoch + 1
    for i in range(0, 1000):
        x_vector_temp = np.append([1], training_set[i])
        # w_array_t = np.transpose(w_array)
        w_array_t = w_array
        cal_output = np.dot(w_array_t, x_vector_temp)
        check_temp = np.ndarray.tolist(training_set[i])
        if cal_output >= 0:
            if not (check_temp in supervised_s_1):
                wrong_classification = wrong_classification + 1
                w_array = w_array - (np.full((1, 3), np.dot(learning_rate, x_vector_temp)))
                """print ("while calculating--", w_array)
                print ("epoch number--", epoch)"""
            else:
                plt.figure(1)
                plt.scatter(training_set[i][0], training_set[i][1], color='blue', s=4)
        else:
            if not (check_temp in supervised_s_0):
                wrong_classification = wrong_classification + 1
                w_array = w_array + (np.full((1, 3), np.dot(learning_rate, x_vector_temp)))
                """print ("while calculating--", w_array)
                print ("epoch number--", epoch)"""
            else:
                plt.figure(1)
                plt.scatter(training_set[i][0], training_set[i][1], color='red', s=4)
    all_weights.append(w_array)
    print (
    "weights after each epoch::", w_array, "epoch Number:", epoch, "misclassification points-->", wrong_classification)
    plt.figure(2)
    plt.plot(epoch, wrong_classification, 'xb-')
    if wrong_classification == 0:
        break

slope_0 = np.true_divide(-w_array[0][1], w_array[0][2])
intercept_0 = np.true_divide(-w_array[0][0], w_array[0][2])
abline(slope_0, intercept_0)
plt.figure(1)
plt.savefig('finalDistribution.png')
plt.figure(2)
plt.xlabel("Number Of Epochs")
plt.ylabel("Number of Wrong Classifications")
plt.savefig('epochVSmisclassifications.png')

print "all the weights are"
print all_weights
print "final weight"
print w_array
print "final epoch number"
print epoch
